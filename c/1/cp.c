/*
 * Да се компилира с флаг `-std=c99`
 * (т.е. командният ред трябва да изглежда по подобен начин:
 *  `cc -std=c99 cp.c -o cp`).
 */

#include <unistd.h>  // тук са дефинирани функциите `open`, `creat`, `read` и `write`
#include <fcntl.h>  // тук е дефиниран макросът `O_RDONLY`

/*
 * Макрос, който дефинира фиксиран размер на буфера.
 * (мислете си за него като за константа, чиято стойност се замества
 *  по време на компилацията на програмата)
 */
#define BUF_SIZE 1000


/*
 * Използваме параметрите на `main` функцията `argc` и `argv`,
 * за да прочетем аргументите, подадени на командния ред.
 */
int main(int argc, char** argv)
{
    /*
     * Проверяваме дали са подадени поне два аргумента,
     * т.е. дали програмата е извикана с команден ред от вида
     * `cp source destination`, където:
     * `source` - пътят към оригиналния файл (от който четем)
     * `destination` - пътят към целевия файл (в който записваме)
     */
    if (argc < 3)  // argc == (броя аргументи) + 1
        return 1;  // ако не са, директно излизаме от програмата с ненулев код за грешка


    int fd_src = open(argv[1], O_RDONLY);  // отваряме оригиналния файл за четене
    int fd_dest = creat(argv[2], 0644);  // отваряме целевия файл за писане, използвайки функцията `creat`, за да може да създадем файла, ако той не съществува (0644 са разрешенията по подразбиране за неизпълними файлове)

    char buf[BUF_SIZE];  // това е буферът, в който ще четем байтовете от файла
    int n;  // тук ще съхраним броя байтове, които сме успели да прочетем от оригиналния файл

    // докато все още има нещо останало за четене от оригиналния файл
    while ((n = read(fd_src, buf, BUF_SIZE)) > 0)  // прочитаме BUF_SIZE на брой байта от оригиналния файл
        write(fd_dest, buf, n);  // записваме `n` на брой байта (колкото сме успели да прочетем от оригиналния файл) в целевия файл

    return 0;
}
