/*
 * Да се компилира с флаг `-std=c99`
 * (т.е. командният ред трябва да изглежда по подобен начин:
 *  `cc -std=c99 cut.c -o cut`).
 */

#include <stdlib.h>  // тук е дефинирана функцията `atoi`
#include <stdbool.h>  // тук са дефинирани типът `bool` и константите `true` и `false`
#include <unistd.h>
#include <fcntl.h>

#define BUF_SIZE 1000


/*
 * В тази функция се ивършва самото "изрязване" на полето с подадения като втори команден аргумент номер:
 * `fd` - файлов дескриптор на файла, от който четем в момента
 * `delim` - знак-разделител между полетата
 * `field` - пореден номер на полето, започвайки от поле номер 1.
 */
void cut(int fd, char delim, int field)
{
    bool in_field = false;  // тази променлива индикира дали сме вътре в рамките на поле в момента
    int c = 0;  // тази променлива съдържа номера на полето, до което сме стигнали в момента

    char buf[BUF_SIZE];
    int n;

    // четем BUF_SIZE байта в буфера, докато можем
    while ((n = read(fd, buf, BUF_SIZE)) > 0)
    {
        // за всеки от `n`-те успешно прочетени байта
        for (int i = 0; i < n; i++)
        {
            // ако той е разделител (т.е. не сме в поле)
            if (delim == buf[i])
                in_field = false;  // отбелязваме, че в момента не се намираме в рамките на поле (напр. излезнали сме от него)
            // ако сме достигнали до символ за край на ред
            else if ('\n' == buf[i])
            {
                in_field = false;  // отбелязваме, че в момента не се намираме в рамките на поле (защото започваме на нов ред)
                c = 0;  // изчистваме номера на текущото поле (пак поради новия ред)
                write(1, buf + i, 1);  // извеждаме символа за нов ред
            }
            // иначе (т.е. сме в поле)
            else
            {
                // ако досега не сме се намирали в рамките на поле
                if (!in_field)
                {
                    c++;  // увеличаваме номера на текущото поле
                    in_field = true;  // отбелязваме, че вече сме навлезли в поле
                }

                // ако сме достигнали до желания от нас номер на поле
                if (field == c)
                    write(1, buf + i, 1);  // извеждаме текущия символ (байт) на стандартния изход.  Използваме `buf + i`, тъй като write приема като втори аргумент стойности от типа `char*`.
            }
        }
    }
}

int main(int argc, char** argv)
{
    /*
     * Проверяваме дали са подадени поне три аргумента,
     * т.е. дали програмата е извикана с команден ред от вида
     * `cut delimiter field file...`, където:
     * `delimiter` - символ-разделител между полетата
     * `field` - пореден номер на поле (започва от 1.)
     * `file` - пътят към изходен файл (от които четем)
     */
    if (argc < 3)
        return 1;

    char delim = argv[1][0];  // вземаме разделителя от първия позиционен команден аргумент
    int field = atoi(argv[2]);  // вземаме номера на полето от втория позиционен команден аргумент

    // ако не са били подадени входни файлове като командни аргументи
    if (argc == 3)
    {
        cut(0, delim, field);  // просто четем от стандартния вход
        return 0;
    }

    // обикаляме всяко едно от подадените като аргументи имена на файлове
    for (int i = 3; i < argc; i++)
    {
        int fd = open(argv[i], O_RDONLY);  // отваряме съответния файл
        cut(fd, delim, field);  // обработваме съответния файл
    }

    return 0;
}
